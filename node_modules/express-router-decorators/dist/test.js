"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = require("ava");
const sinon = require("sinon");
const index_1 = require("./index");
ava_1.default('@Root should add static "ROOT_ROUTE" property to class', t => {
    const rootRoute = '/root';
    let Target = class Target {
    };
    Target = __decorate([
        index_1.Root(rootRoute)
    ], Target);
    t.true(Target['ROOT_ROUTE'] === rootRoute);
});
ava_1.default('@Path with 1 arg should add "PATH_ROUTE" property to method and default "HTTP_METHOD" equal to "get"', t => {
    const path = '/path';
    class Target {
        method() { }
    }
    __decorate([
        index_1.Path(path),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Target.prototype, "method", null);
    t.true(Target.prototype.method['PATH_ROUTE'] === path);
    t.true(Target.prototype.method['HTTP_METHOD'] === 'get');
});
ava_1.default('@Path with 2 args should add "PATH_ROUTE" & "HTTP_METHOD" properties to method', t => {
    const path = '/path';
    const httpMethod = 'put';
    class Target {
        method() { }
    }
    __decorate([
        index_1.Path(path, httpMethod),
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Target.prototype, "method", null);
    t.true(Target.prototype.method['PATH_ROUTE'] === path);
    t.true(Target.prototype.method['HTTP_METHOD'] === httpMethod);
});
ava_1.default('@Use should mark the method as router middleware by adding "MIDDLEWARE" property', t => {
    class Target {
        method() { }
    }
    __decorate([
        index_1.Use,
        __metadata("design:type", Function),
        __metadata("design:paramtypes", []),
        __metadata("design:returntype", void 0)
    ], Target.prototype, "method", null);
    t.true(Target.prototype.method['MIDDLEWARE']);
});
ava_1.default('bindControllers should add the controller to the app at given root path', t => {
    const appMock = {
        use: sinon.spy()
    };
    const rootRoute = '/root';
    let Target = class Target {
    };
    Target = __decorate([
        index_1.Root(rootRoute)
    ], Target);
    index_1.bindControllers(appMock, Target);
    t.true(appMock.use.calledWith(rootRoute, sinon.match.any));
});
ava_1.default('bindControllers should throw an Error if \'@Root\' decorator was not used on a class', t => {
    const appMock = {};
    class Target {
    }
    t.throws(() => index_1.bindControllers(appMock, Target), Error);
});
//# sourceMappingURL=test.js.map