"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const express = require("express");
const ROOT_ROUTE = 'ROOT_ROUTE';
const PATH_ROUTE = 'PATH_ROUTE';
const HTTP_METHOD = 'HTTP_METHOD';
const MIDDLEWARE = 'MIDDLEWARE';
const startsWithForwardSlashRegExp = /^\//;
function Root(rootRoute) {
    return function (target) {
        target[ROOT_ROUTE] = rootRoute;
    };
}
exports.Root = Root;
function Path(pathRoute, httpMethod) {
    return function (target, propertyKey) {
        target[propertyKey][PATH_ROUTE] = pathRoute;
        target[propertyKey][HTTP_METHOD] = (httpMethod || 'get').toLowerCase();
    };
}
exports.Path = Path;
function Use(target, propertyKey) {
    target[propertyKey][MIDDLEWARE] = true;
}
exports.Use = Use;
/**
 * Attaches the router controllers to the main express application instance.
 * @param app - express application instance (result of call to `express()`)
 * @param controllers - controller classes decorated with @Root and @Path/@Use
 */
function bindControllers(app, ...controllers) {
    for (const Clazz of controllers) {
        const router = express.Router();
        const instance = new Clazz();
        const rootRoute = Clazz[ROOT_ROUTE];
        if (!rootRoute || !startsWithForwardSlashRegExp.test(rootRoute)) {
            // TODO test it
            throw new Error('Class-level \'@Root\' decorator must be used with single string argument starting with forward slash (eg. \'/\' or \'/myRoot\')!');
        }
        // @Use
        const middlewareDeclarationMethods = getClassMethodsByDecoratedProperty(Clazz, MIDDLEWARE);
        middlewareDeclarationMethods.forEach(middlewareDeclarationMethod => {
            router.use(instance[middlewareDeclarationMethod].bind(instance));
        });
        // @Path
        const pathRouteMethods = getClassMethodsByDecoratedProperty(Clazz, PATH_ROUTE);
        pathRouteMethods.forEach(pathRouteMethod => {
            const { PATH_ROUTE, HTTP_METHOD } = instance[pathRouteMethod];
            router[HTTP_METHOD](PATH_ROUTE, instance[pathRouteMethod].bind(instance));
        });
        app.use(rootRoute, router);
    }
}
exports.bindControllers = bindControllers;
/**
 * Recursively (taking into account super classes) find names of the methods, that were decorated with given property, in a class.
 * @param clazz - target class
 * @param decoratedPropertyName - name of the property known to be added by decorator, eg. 'ROOT_ROUTE'
 * @param foundMethodsNames - array of methods names found (useful when concatenating results of recursive search through superclasses)
 */
function getClassMethodsByDecoratedProperty(clazz, decoratedPropertyName, foundMethodsNames = []) {
    const clazzMethods = foundMethodsNames.concat(Object.getOwnPropertyNames(clazz.prototype)
        .filter(functionName => functionName !== 'constructor')
        .filter(functionName => clazz.prototype[functionName][decoratedPropertyName] !== undefined));
    const parentClazz = Object.getPrototypeOf(clazz);
    if (parentClazz.name !== '') {
        return getClassMethodsByDecoratedProperty(parentClazz, decoratedPropertyName, clazzMethods);
    }
    // returns an array of *unique* method names
    return clazzMethods.filter((methodName, index, array) => array.indexOf(methodName) === index);
}
// optTODO add middleware to @Path (see https://github.com/buunguyen/route-decorators)
// DONE test with babel decorators - works with *-legacy
// DONE unit tests
// TODO description in package.json
// TODO readme
// TODO npm publish
// comparison
// https://github.com/buunguyen/route-decorators - does not have all express-supported methods, seems not to have something like bindControllers (?)
// https://www.npmjs.com/package/express-decorators - has middleware, nice - but decorators look bad and you have to instantiate the controllers by yourself
// https://www.npmjs.com/package/ts-express-decorators - big, quite complicated
//# sourceMappingURL=index.js.map